# 1. 包装类

## 1.1 包装类：基本数据类型对应的引用类型

## 1.2 包装类都有什么

​	int -> Integer
​	long -> Long
​	short -> Short
​	byte -> Byte
​	float -> Float
​	double -> Double

​	boolean -> Boolean
​	char -> Character

## 1.3 包装类的作用

为了使得基本数据类型的变量具备引用数据类型变量的特征（比如：封装性，继承性，多态性，）我们给各个基本数据类型都提供了包装类

## 1.4 基本数据类型 与 包装类 之间的转换

### 1.4.1 为什么需要转换

> 一方面在有些场景下，需要使用基本数据类型对应的包装类的对象，此时就需要将基本数据类型转换为对应的包装类对象。
> 比如：ArrayList的add方法，要求的是Object类型的参数，而基本数据类型不能作为Object类型的参数。<br>
> 另一方面在有些场景下，需要使用基本数据类型对应的包装类的对象，此时就需要将基本数据类型转换为对应的包装类对象。

### 1.4.2 基本数据类型 与 包装类 之间的转换

基本数据类型 -> 包装类： 1.使用包装类的构造器
2. 建议使用包装类的valueOf()方法

包装类 -> 基本数据类型：1. 调用包装类的xxxValue()方法

自动拆箱：将包装类对象转换为基本数据类型
自动装箱：将基本数据类型转换为包装类对象

### 1.4.3 包装类 与 基本数据类型 之间的转换

1. 自动装箱：将基本数据类型转换为包装类对象
2. 自动拆箱：将包装类对象转换为基本数据类型

## 1.4 String 与基本数据类型，包装类之间的转换

## 1.5 重点

1. 自动装箱：将基本数据类型转换为包装类对象
2. 自动拆箱：将包装类对象转换为基本数据类型

3.包装类缓存对象

包装类             缓存对象
Byte                -128 ~ 127
Short               -128 ~ 127
Integer             -128 ~ 127
Long                没有缓存对象
Float               没有缓存对象
Double              -128 ~ 127
Boolean             true,false
Character           \u0000 ~ \uFFFF

案例：

        Integer m = 1;
        Integer n = 1;
        System.out.println(m == n);//true
    
        Integer x = 128;
        Integer y = 128;
        System.out.println(x == y);//false

# 2. 异常捕获与抛出

## 2.1 什么是异常
指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止。

## 2.2 异常的抛出机制
Java中把不同的异常用不同的类表示，一旦发生某种异常，就`创建该异常类型的对象`，并且抛出（throw）。
然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常
对象将会导致程序终止。

## 2.3 异常的体系结构

```
java.lang.Throwable:异常体系的根父类
    |---java.lang.Error:错误。Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。
                         一般不编写针对性的代码进行处理。
               |---- StackOverflowError、OutOfMemoryError



|---java.lang.Exception:异常。我们可以编写针对性的代码进行处理。
           |----编译时异常：(受检异常)在执行javac.exe命令时，出现的异常。
                |----- ClassNotFoundException            类未找到
                |----- FileNotFoundException               文件未找到
                |----- IOException                        输入输出异常
           |----运行时异常：(非受检异常)在执行java.exe命令时，出现的异常。
                |---- ArrayIndexOutOfBoundsException     角标越界
                |---- NullPointerException               空指针
                |---- ClassCastException                 类型转换
                |---- NumberFormatException              数字格式
                |---- InputMismatchException             输入不匹配
                |---- ArithmeticException                算术异常：比如分母不能为0
```



## 2.4 错误与异常

**Error：**Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。

- 例如：StackOverflowError（栈内存溢出）和OutOfMemoryError（堆内存溢出，简称OOM）。

**Exception:** 其它因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行。否则一旦发生异常，程序也会挂掉。例如：

- 空指针访问
- 试图读取不存在的文件
- 网络连接中断
- 数组角标越界

## 2.5 异常处理

### 2.5.1 try-catch-finally(抓抛模型)

#### 2.5.1.1 过程：

抛： 程序在执行的过程中，一旦出现异常，就会在出现异常的代码处，生成对应异常类的对象，并将此对象抛出。
     一旦抛出，此程序就不执行气候的代码了
抓：针对于过程1 中抛出的异常对象进行捕获处理，这个过程就叫做抓
     一旦将异常进行了处理，代码就可以继续执行。

#### 2.5.1.2 语法结构：
```java
try{
     .....//可能出现异常的代码
}catch(异常类型1 e){
     ......//当产生异常类型1时的处理措施
}catch(异常类型2 e){
     ......//当产生异常类型2时的处理措施
}finally(
     ......//无论是否发生异常，都无条件执行的语句
)

}
```



#### 2.5.1.3 注意：
1.如果声明了多个catch结构，不同的异常类型在不存在字符类的情况下，谁声明在上边，谁声明在下面都可以
   如果多个异常类型满足字符类的关系，则必须将子类声明在父类结构的上面，否则会报错
2.catch中异常处理的方式：
   1.自己编写提示语句
   2.printStackTrace()：打印异常的详细信息（推荐）
   3.e.getMessage():获取发生异常的原因（需要打印输出）
3.try中声明的变量，出了try之后，就不可以被使用了

#### 2.5.1.4 开发体会：
>1. 对于运行时异常：
        开发中通常就不进行显示的处理了，一旦在程序执行中，出现了运行时异常，那么根据异常的信息更改就好
>2. 对于编译时异常：
        开发中必须进行显示的处理，否则程序编译不通过。

#### 2.5.1.5 finally块
1. 将一定要被执行的代码声明在fianlly中。

2. 更深刻的理解：无论try中或vatch中是否存在仍未被处理的异常，无论try或catch中是否存在return语句等，
        finally中声明的语句都一定要被执行。

3. 如果运行时异常中，我们有要想一定被执行的语句，可以使用try-finally结构来处理。

#### 2.5.1.6 什么样的代码应该声明在finally中
>在开发中，一些资源，如：输入输出流，网络连接，Socket连接，数据库连接等，我们在使用完毕后，需要显式关闭资源，不然GC可能不会自动的回收这些资源，进而导致内存的泄露
     为了保证这些资源在使用完以后，不管是否出现了未备注里的异常的情况下，这些异常都能被关闭，所以，我们必须将这些操作声明在finally中。

### 2.5.2 异常处理的方式三：throws + 异常类型

#### 2.5.2.1 格式：
```java
public void method() throws ExceptionType1,ExceptionType2,...{
     //方法体
}
```



#### 2.5.2.2 注意:

1. 是否真正的处理了异常？

​	->从编译是否能通过的角度看，看成是给出了异常万一要是出现的时候的解决方案，此方案就是继续向上抛出

​	->但是，throws方式仅是将可能出现的异常抛给了此方法的调用者，调用者仍然需要考虑如何处理相关异常，从这个角度来看并没有

2. **方法重写的要求：**

​	->子类重写的方法抛出的异常类型可以与父类中被重写的方法抛出的异常类型相容，或是父类被重写的方法抛出的异常类型的子类



### 2.5.3 两种方法的选择

> 1. 如果程序代码中，涉及到资源的调用（流，数据库连接，网络连接等），则必须考虑吧使用try-catch结构来处理，保证不出现内存泄漏问题
>
> 2. 如果父类被重写的方法中没有throws异常类型，则子类重写的方法中如果出现了异常，只能考虑使用try-catch进行处理。
> 3. 开发中方法a依次调用了方法b,c,d,等方法，方法b,c,d之间是递进关系，此时，如果方法b,c,d中有异常，我们通常选择使用throws，而方法a中通常选择使用try-catch结构



#      2. 多线程



## 2.1相关概念

### 2.1.1 程序，进程和线程的区分：

* **程序（program）**：为完成特定任务，用某种语言编写的`一组指令的集合`。即指`一段静态的代码`，静态对象。

* **进程（process）**：程序的一次执行过程，或是正在内存中运行的应用程序。如：运行中的QQ，运行中的网易音乐播放器。
    * 每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期）
    * 程序是静态的，进程是动态的
    * 进程作为`操作系统调度和分配资源的最小单位`（亦是系统运行程序的基本单位），系统在运行时会为每个进程分配不同的内存区域。
    * 现代的操作系统，大都是支持多进程的，支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。
* **线程（thread）**：进程可进一步细化为线程，是程序内部的`一条执行路径`。一个进程中至少有一个线程。

    - 一个进程同一时间若`并行`执行多个线程，就是支持多线程的。

    - 线程作为**CPU调度和执行的最小单位**。

    - 一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来`安全的隐患`。

### 2.1.2 线程调度策略

-   分时调度：所有线程**轮流使用**CPU的使用权，并且**平均分配**每个线程占用CPU的时间。
-   抢占式调度：让**优先级高**的线程以较大的概率优先使用CPU，如果线程的优先级相同，那么会随机选择一个（线程的随机性）

线程的优先级

### 2.1.3了解







## 2.2 线程的创建

### 2.2.1 方式一：继承Thread类

#### 2.2.1.1步骤：

1.   创建一个继承于Tread类的子类
2.   重写Thread中的run()   ------>  将此线程要执行的操作，声明在此方法体内
3.   创建当前Thread的子类的对象
4.   通过对象调用start()方法 :  1.启动线程，2.调用当前线程中的run()

#### 2.2.1.2 例题：创建一个分线程1，用于遍历100以内的偶数

【拓展 】 再创建一个分线程2，用于遍历100以内的偶数



```java
// 偶数
class PrintNumberOu extends Thread {
  @Override
  public void **run**() {
​    for (int i = 0; i <= 100; i += 2) {
​      System.out.**println**(Thread.**currentThread**().**getName**() + "----->" + i);
​    }
  }
}
```

### 2.2.2 方式二：实现Runnable接口

#### 2.2.2.1步骤：

1.   创建一个实现Runnable接口的类
2.   实现接口中的run()方法  ---->  将此线程要执行的操作，声明在此方法体内
3.   创建当前实现类的对象
4.   将此对象作为参数传递到Thread类的构造器中，创建Thread类的实例
5.   Thread类的实例调用start():1.启动线程，2.调用当前线程中的run()

#### 2.2.2.2 例题：

创建一个分线程1，用于遍历100以内的奇数

```java
*// 1.  创建一个实现Runnable接口的类*

class PrintNumber implements Runnable{

*// 2.  实现接口中的run()方法  ---->  将此线程要执行的操作，声明在此方法体内*   
  @Override
  public void **run**(){
​    for (int i = 1; i <= 100; i += 2) {
​      System.out.**println**(Thread.**currentThread**().**getName**() + " : " + i);
​    }
  }
}
```



## 2.3 两种线程创建方法的比较

共同点：1. 启动线程，使用的都是Thread类中定义的start()

·		2. 创建的线程对象，都是Thread类或其子类的实例 

不同点：一个是类的继承，一个是接口的实现

​	建议：建议使用事实现Runnable接口的方式

​		Runnable方式的好处： 1. 实现的方式，避免的类的单继承的局限性

​							 2. 更适合处理有共享数据的问题。

​							 3.  实现了数据和代码的分离。

联系：public class Thread implements Runnable（代理模式）



## 2.4 线程的常用结构

1.   线程中的构造器：

-   public Thread() : 分配一个新的线程对象。
-   public Thread(String name) : 分配一个指定名字的新的线程对象。
-   public Thread(Runnable target)  ： 指定创建现成的目标对象，它实现了Runnable接口的run方法
-   public Thread(Runnable target，  String name)  ：分配·一个带有指定目标新的线程对象并指定名字



2.   线程中的常用方法：

>start():启动线程，调用线程的run()
>
>run(): 将线程要执行的操作，声明再run()中
>
>currentThread():获取当前执行代码对应的线程
>
>getname(): 获取线程名字
>
>setName(): 设置线程名称
>
>sleep(long millis ) :静态方法，调用时，可以是的当前线程睡眠指定的毫秒数
>
>yield():一旦执行此方法，就释放CPU的执行权
>
>join():在线程a中通过线程b调用join(),意味着a进入堵塞状态，直到线程B执行结束，线程a才结束阻塞状态，继续执行。
>
>isAlive():判断当前线程是否存活

过时方法：

>   public final void stop():**已过时，*不建议使用***  强行结束一个线程的执行，直接进入死亡状态。
>
>   void suspend() / void resume():可能造成死锁，不建议使用，相当于音乐的播放与暂停按键，必须成对存在。



## 2.5 线程的优先级：

getPriority():获取线程的优先级

Thread类的三个优先级常量：

-   MAX_PRIORITY(10) : 最高优先级
-   MIN——PRIORITY(1): 最低优先级
-   NORM_PRIORITY(5)：普通优先级

注意：优先级高也只是概率较大，并不一定优先。



## 2.6 线程的生命周期：



1.   JDK 5.0 之前

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20251017202546479.png" alt="image-20251017202546479" style="zoom:50%;" />

2.   

<img src="C:\Users\lenovo\Desktop\文件夹\java\尚硅谷_第10章_多线程\images\image-20220524203355448.png" alt="image-20220524203355448" style="zoom: 45%;" />

## 2.7 线程的安全问题及解决

