# 1. 包装类

## 1.1 包装类：基本数据类型对应的引用类型

## 1.2 包装类都有什么

​	int -> Integer
​	long -> Long
​	short -> Short
​	byte -> Byte
​	float -> Float
​	double -> Double

​	boolean -> Boolean
​	char -> Character

## 1.3 包装类的作用

为了使得基本数据类型的变量具备引用数据类型变量的特征（比如：封装性，继承性，多态性，）我们给各个基本数据类型都提供了包装类

## 1.4 基本数据类型 与 包装类 之间的转换

### 1.4.1 为什么需要转换

> 一方面在有些场景下，需要使用基本数据类型对应的包装类的对象，此时就需要将基本数据类型转换为对应的包装类对象。
> 比如：ArrayList的add方法，要求的是Object类型的参数，而基本数据类型不能作为Object类型的参数。<br>
> 另一方面在有些场景下，需要使用基本数据类型对应的包装类的对象，此时就需要将基本数据类型转换为对应的包装类对象。

### 1.4.2 基本数据类型 与 包装类 之间的转换

基本数据类型 -> 包装类： 1.使用包装类的构造器
2. 建议使用包装类的valueOf()方法

包装类 -> 基本数据类型：1. 调用包装类的xxxValue()方法

自动拆箱：将包装类对象转换为基本数据类型
自动装箱：将基本数据类型转换为包装类对象

### 1.4.3 包装类 与 基本数据类型 之间的转换

1. 自动装箱：将基本数据类型转换为包装类对象
2. 自动拆箱：将包装类对象转换为基本数据类型

## 1.4 String 与基本数据类型，包装类之间的转换

## 1.5 重点

1. 自动装箱：将基本数据类型转换为包装类对象
2. 自动拆箱：将包装类对象转换为基本数据类型

3.包装类缓存对象

包装类             缓存对象
Byte                -128 ~ 127
Short               -128 ~ 127
Integer             -128 ~ 127
Long                没有缓存对象
Float               没有缓存对象
Double              -128 ~ 127
Boolean             true,false
Character           \u0000 ~ \uFFFF

案例：

        Integer m = 1;
        Integer n = 1;
        System.out.println(m == n);//true
    
        Integer x = 128;
        Integer y = 128;
        System.out.println(x == y);//false

# 2. 异常捕获与抛出

## 2.1 什么是异常
指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止。

## 2.2 异常的抛出机制
Java中把不同的异常用不同的类表示，一旦发生某种异常，就`创建该异常类型的对象`，并且抛出（throw）。
然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常
对象将会导致程序终止。

## 2.3 异常的体系结构

```
java.lang.Throwable:异常体系的根父类
    |---java.lang.Error:错误。Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。
                         一般不编写针对性的代码进行处理。
               |---- StackOverflowError、OutOfMemoryError



|---java.lang.Exception:异常。我们可以编写针对性的代码进行处理。
           |----编译时异常：(受检异常)在执行javac.exe命令时，出现的异常。
                |----- ClassNotFoundException            类未找到
                |----- FileNotFoundException               文件未找到
                |----- IOException                        输入输出异常
           |----运行时异常：(非受检异常)在执行java.exe命令时，出现的异常。
                |---- ArrayIndexOutOfBoundsException     角标越界
                |---- NullPointerException               空指针
                |---- ClassCastException                 类型转换
                |---- NumberFormatException              数字格式
                |---- InputMismatchException             输入不匹配
                |---- ArithmeticException                算术异常：比如分母不能为0
```



## 2.4 错误与异常

**Error：**Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。

- 例如：StackOverflowError（栈内存溢出）和OutOfMemoryError（堆内存溢出，简称OOM）。

**Exception:** 其它因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行。否则一旦发生异常，程序也会挂掉。例如：

- 空指针访问
- 试图读取不存在的文件
- 网络连接中断
- 数组角标越界

## 2.5 异常处理

### 2.5.1 try-catch-finally(抓抛模型)

#### 2.5.1.1 过程：

抛： 程序在执行的过程中，一旦出现异常，就会在出现异常的代码处，生成对应异常类的对象，并将此对象抛出。
     一旦抛出，此程序就不执行气候的代码了
抓：针对于过程1 中抛出的异常对象进行捕获处理，这个过程就叫做抓
     一旦将异常进行了处理，代码就可以继续执行。

#### 2.5.1.2 语法结构：
```java
try{
     .....//可能出现异常的代码
}catch(异常类型1 e){
     ......//当产生异常类型1时的处理措施
}catch(异常类型2 e){
     ......//当产生异常类型2时的处理措施
}finally(
     ......//无论是否发生异常，都无条件执行的语句
)

}
```



#### 2.5.1.3 注意：
1.如果声明了多个catch结构，不同的异常类型在不存在字符类的情况下，谁声明在上边，谁声明在下面都可以
   如果多个异常类型满足字符类的关系，则必须将子类声明在父类结构的上面，否则会报错
2.catch中异常处理的方式：
   1.自己编写提示语句
   2.printStackTrace()：打印异常的详细信息（推荐）
   3.e.getMessage():获取发生异常的原因（需要打印输出）
3.try中声明的变量，出了try之后，就不可以被使用了

#### 2.5.1.4 开发体会：
>1. 对于运行时异常：
        开发中通常就不进行显示的处理了，一旦在程序执行中，出现了运行时异常，那么根据异常的信息更改就好
>2. 对于编译时异常：
        开发中必须进行显示的处理，否则程序编译不通过。

#### 2.5.1.5 finally块
1. 将一定要被执行的代码声明在fianlly中。

2. 更深刻的理解：无论try中或vatch中是否存在仍未被处理的异常，无论try或catch中是否存在return语句等，
        finally中声明的语句都一定要被执行。

3. 如果运行时异常中，我们有要想一定被执行的语句，可以使用try-finally结构来处理。

#### 2.5.1.6 什么样的代码应该声明在finally中
>在开发中，一些资源，如：输入输出流，网络连接，Socket连接，数据库连接等，我们在使用完毕后，需要显式关闭资源，不然GC可能不会自动的回收这些资源，进而导致内存的泄露
     为了保证这些资源在使用完以后，不管是否出现了未备注里的异常的情况下，这些异常都能被关闭，所以，我们必须将这些操作声明在finally中。

### 2.5.2 异常处理的方式三：throws + 异常类型

#### 2.5.2.1 格式：
```java
public void method() throws ExceptionType1,ExceptionType2,...{
     //方法体
}
```



#### 2.5.2.2 注意:

1. 是否真正的处理了异常？

​	->从编译是否能通过的角度看，看成是给出了异常万一要是出现的时候的解决方案，此方案就是继续向上抛出

​	->但是，throws方式仅是将可能出现的异常抛给了此方法的调用者，调用者仍然需要考虑如何处理相关异常，从这个角度来看并没有

2. **方法重写的要求：**

​	->子类重写的方法抛出的异常类型可以与父类中被重写的方法抛出的异常类型相容，或是父类被重写的方法抛出的异常类型的子类



### 2.5.3 两种方法的选择

> 1. 如果程序代码中，涉及到资源的调用（流，数据库连接，网络连接等），则必须考虑吧使用try-catch结构来处理，保证不出现内存泄漏问题
>
> 2. 如果父类被重写的方法中没有throws异常类型，则子类重写的方法中如果出现了异常，只能考虑使用try-catch进行处理。
> 3. 开发中方法a依次调用了方法b,c,d,等方法，方法b,c,d之间是递进关系，此时，如果方法b,c,d中有异常，我们通常选择使用throws，而方法a中通常选择使用try-catch结构





