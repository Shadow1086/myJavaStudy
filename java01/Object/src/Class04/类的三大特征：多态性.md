# 多态性 (Polymorphism)

## 1. 什么是多态
同一引用类型的变量，指向不同实际类型（对象）时，通过该引用调用同一方法，会表现出不同的实现（行为）。简言之：同一接口，多个实现；同一父类引用，运行期调用不同版本的方法。

## 2. 多态的体现形式
1. 继承体系中：方法重写 (Override)
2. 接口实现：不同类实现同一接口的方法
3. 抽象类：子类实现抽象方法

> 关键点：Java 运行期根据对象的“实际类型”决定调用哪个重写方法，这就是动态绑定（Dynamic Binding）。
> 动态绑定，编译和与运行不是同一个方法。

## 3. 形成多态的必要条件（缺一不可）
1. 必须存在继承或实现关系
2. 必须发生方法重写（子类对父类的同名同参非 private、非 static 方法进行覆盖）
3. 通过父类（或接口）类型的引用指向子类对象（向上转型 / Upcasting）

示例：
```java
Person p = new Student();  // 向上转型
p.eat(); // 实际执行 Student 重写后的 eat()
```

## 4. 方法调用的编译期与运行期机制：虚拟方法调用
在多态的场景下，调用方法时。

- 编译时，认为方法是左边声明的父类的类型的方法（即被重写的方法）
- 执行式，实际执行的是子类重写父类的方法。

简称为：**_编译看左边，运行看右边。_**

```java
class Person {
    public void eat() { System.out.println("Person 吃饭"); }
}
class Student extends Person {
    @Override
    public void eat() { System.out.println("Student 吃食堂"); }
    public void study() { System.out.println("Student 学习"); }
}

Person p = new Student();
p.eat();      // 输出：Student 吃食堂
// p.study(); // 编译错误：编译期按 Person 类型检查，Person 中无 study()
```

## 5. 哪些成员不具备多态性
以下成员访问只看“引用的编译期类型”，不发生运行期动态绑定：

- 成员变量（属性/字段）
- static 静态方法
- private 方法（因不能被重写）
- 构造器（不参与继承与重写）
- 方法重载（Overload）与多态无关，它是编译期行为

## 6. 向下转型（Downcasting）与 instanceof
当需要访问子类特有成员时，需要把父类引用“还原”为子类引用，并在转型前用 instanceof 保护：
```java
if (p instanceof Student) { // 避免 ClassCastException
    Student stu = (Student) p; // 向下转型
    stu.study();
}
```
建议在向下转型之前，使用instanceof进行判断，避免出现类型转换异常

格式： a instanceof A :判断对象a是否是类A的实例。

如果  a instanceof A 返回true，则：
          a instanceof superA  返回也是true，其中 A是SuperA的子类。

## 7. 多态的优势
1. 可扩展性：新增子类时，原有依赖父类/接口的方法无需修改（开闭原则）
2. 可维护性：调用端面向抽象编程，降低耦合
3. 代码复用：统一处理一组具有共同行为的不同对象
4. 便于实现设计模式（工厂、策略、模板方法、适配器等）

## 8. 多态的局限 / 劣势
1. 不能直接访问子类特有成员（需向下转型）
2. 过度层次化会增加理解成本
3. 频繁的虚方法调用在极端性能场景下有微小开销（通常可忽略）

## 9. 典型使用场景
- 方法形参使用父类或接口类型：
```java
public void feed(Person p) { // 或接口类型 Runnable / List / ...
    p.eat();
}
```
- 集合统一存放父类/接口类型，运行期表现不同：
```java
List<Person> list = new ArrayList<>();
list.add(new Student());
list.add(new Teacher());
for (Person person : list) {
    person.eat(); // 逐个触发不同实现
}
```
- 策略/工厂/模板方法等模式中，通过抽象父类或接口屏蔽实现差异

## 10. 与“重载”区别速览
| 对比项 | 重写 Override | 重载 Overload |
|--------|---------------|---------------|
| 发生位置 | 父子类之间 | 同一个类内（或父子链中同层判定） |
| 参数列表 | 必须相同 | 必须不同（类型/个数/顺序） |
| 访问修饰 | 子类权限 >= 父类 | 无硬性要求 |
| 返回类型 | 可协变（返回子类型） | 可不同（与是否构成重载无直接关系） |
| 绑定时间 | 运行期（动态绑定） | 编译期（静态绑定） |
| 是否体现多态 | 是 | 否 |

## 11. 小结
- “父类引用指向子类对象”+“方法被子类重写” = 运行期多态
- 编译看左（引用类型），运行看右（实际对象）
- 字段、static、private、构造器不具备多态
- 想用子类特有成员：先 instanceof，再向下转型
- 面向抽象编程，减少耦合，提升扩展性

## 12. 练习建议
1. 写一个父类 `Animal`，两个子类 `Dog`、`Cat`，统一放入 `List<Animal>` 遍历调用 `shout()`。
2. 增加一个新子类 `Bird`，验证是否无需改动遍历逻辑即可生效。
3. 添加子类特有方法，练习安全向下转型访问。
